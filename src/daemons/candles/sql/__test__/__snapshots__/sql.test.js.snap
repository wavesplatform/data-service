// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`candles daemon sql test calculate and insert all candles from other small candles 1`] = `"insert into \\"candles\\" select to_timestamp(floor((extract('epoch' from time_start) / 300 )) * 300) as \\"candle_time\\", \\"amount_asset_id\\" as \\"amount_asset_id\\", \\"price_asset_id\\" as \\"price_asset_id\\", (select min(\\"low\\")) as \\"low\\", (select max(\\"high\\")) as \\"high\\", (select sum(\\"volume\\")) as \\"volume\\", (select sum(\\"quote_volume\\")) as \\"quote_volume\\", (select max(\\"max_height\\")) as \\"max_height\\", (select sum(\\"txs_count\\")) as \\"txs_count\\", (sum((weighted_average_price * volume)::numeric)::numeric / sum(volume)::numeric)::numeric as \\"weighted_average_price\\", (array_agg(open ORDER BY time_start)::numeric[])[1] as \\"open\\", (array_agg(close ORDER BY time_start DESC)::numeric[])[1] as \\"close\\", 300 as \\"interval_in_secs\\", \\"matcher\\" as \\"matcher\\" from \\"candles\\" as \\"t\\" where \\"t\\".\\"interval_in_secs\\" = 60 group by \\"candle_time\\", \\"amount_asset_id\\", \\"price_asset_id\\", \\"matcher\\""`;

exports[`candles daemon sql test get all candles from exchange tx grouped by 1 minute and after timestamp 1`] = `"select e.candle_time as \\"time_start\\", \\"amount_asset\\" as \\"amount_asset_id\\", \\"price_asset\\" as \\"price_asset_id\\", min(e.price * 10 ^(-8 - p_dec.decimals + a_dec.decimals)) as \\"low\\", max(e.price * 10 ^(-8 - p_dec.decimals + a_dec.decimals)) as \\"high\\", sum(e.amount * 10 ^(-a_dec.decimals)) as \\"volume\\", sum(e.amount * 10 ^(-a_dec.decimals) * e.price * 10 ^(-8 - p_dec.decimals + a_dec.decimals)) as \\"quote_volume\\", (select max(\\"height\\")) as \\"max_height\\", count(e.price) as \\"txs_count\\", sum((e.amount * 10 ^(-a_dec.decimals))::numeric * (e.price * 10 ^(-8 - p_dec.decimals + a_dec.decimals))::numeric)/sum((e.amount * 10 ^(-a_dec.decimals))::numeric) as \\"weighted_average_price\\", (array_agg(e.price * 10 ^(-8 - p_dec.decimals + a_dec.decimals) ORDER BY e.candle_time)::numeric[])[1] as \\"open\\", (array_agg(e.price * 10 ^(-8 - p_dec.decimals + a_dec.decimals) ORDER BY e.candle_time DESC)::numeric[])[1] as \\"close\\", 60 as \\"interval_in_secs\\", \\"sender\\" as \\"matcher\\" from (select \\"amount_asset\\", \\"price_asset\\", \\"sender\\", \\"height\\", date_trunc('minute', t.time_stamp) as \\"candle_time\\", \\"amount\\", \\"price\\" from \\"txs_7\\" as \\"t\\" where t.time_stamp >= date_trunc('minute', '2019-01-01T00:00:00.000Z'::timestamp)) as \\"e\\" inner join \\"asset_decimals\\" as \\"a_dec\\" on \\"e\\".\\"amount_asset\\" = \\"a_dec\\".\\"asset_id\\" inner join \\"asset_decimals\\" as \\"p_dec\\" on \\"e\\".\\"price_asset\\" = \\"p_dec\\".\\"asset_id\\" group by \\"e\\".\\"candle_time\\", \\"e\\".\\"amount_asset\\", \\"e\\".\\"price_asset\\", \\"e\\".\\"sender\\""`;

exports[`candles daemon sql test get last candle 1`] = `"select \\"max_height\\" from \\"candles\\" as \\"t\\" order by \\"max_height\\" desc limit 1"`;

exports[`candles daemon sql test get last exchange tx 1`] = `"select \\"height\\" from \\"txs_7\\" as \\"t\\" order by \\"height\\" desc limit 1"`;

exports[`candles daemon sql test insert all candles group by 1 minute 1`] = `"insert into \\"candles\\" select e.candle_time as \\"time_start\\", \\"amount_asset\\" as \\"amount_asset_id\\", \\"price_asset\\" as \\"price_asset_id\\", min(e.price * 10 ^(-8 - p_dec.decimals + a_dec.decimals)) as \\"low\\", max(e.price * 10 ^(-8 - p_dec.decimals + a_dec.decimals)) as \\"high\\", sum(e.amount * 10 ^(-a_dec.decimals)) as \\"volume\\", sum(e.amount * 10 ^(-a_dec.decimals) * e.price * 10 ^(-8 - p_dec.decimals + a_dec.decimals)) as \\"quote_volume\\", (select max(\\"height\\")) as \\"max_height\\", count(e.price) as \\"txs_count\\", sum((e.amount * 10 ^(-a_dec.decimals))::numeric * (e.price * 10 ^(-8 - p_dec.decimals + a_dec.decimals))::numeric)/sum((e.amount * 10 ^(-a_dec.decimals))::numeric) as \\"weighted_average_price\\", (array_agg(e.price * 10 ^(-8 - p_dec.decimals + a_dec.decimals) ORDER BY e.candle_time)::numeric[])[1] as \\"open\\", (array_agg(e.price * 10 ^(-8 - p_dec.decimals + a_dec.decimals) ORDER BY e.candle_time DESC)::numeric[])[1] as \\"close\\", 60 as \\"interval_in_secs\\", \\"sender\\" as \\"matcher\\" from (select \\"amount_asset\\", \\"price_asset\\", \\"sender\\", \\"height\\", date_trunc('minute', t.time_stamp) as \\"candle_time\\", \\"amount\\", \\"price\\" from \\"txs_7\\" as \\"t\\") as \\"e\\" inner join \\"asset_decimals\\" as \\"a_dec\\" on \\"e\\".\\"amount_asset\\" = \\"a_dec\\".\\"asset_id\\" inner join \\"asset_decimals\\" as \\"p_dec\\" on \\"e\\".\\"price_asset\\" = \\"p_dec\\".\\"asset_id\\" group by e.candle_time, e.amount_asset, e.price_asset, e.sender"`;

exports[`candles daemon sql test insert or update array of candles 1`] = `"insert into \\"candles\\" as \\"t\\" (\\"amount_asset_id\\", \\"close\\", \\"high\\", \\"interval_in_secs\\", \\"low\\", \\"matcher\\", \\"max_height\\", \\"open\\", \\"price_asset_id\\", \\"quote_volume\\", \\"time_start\\", \\"txs_count\\", \\"volume\\", \\"weighted_average_price\\") values ('1', '80', '100', 60, '1', DEFAULT, DEFAULT, '20', '2', '100.2', '1970-01-01 03:00:00.000', '22', '200.2', '2.1') on conflict (time_start, amount_asset_id, price_asset_id, matcher, interval_in_secs) do update set open=EXCLUDED.open, close=EXCLUDED.close, low=EXCLUDED.low, high=EXCLUDED.high, max_height=EXCLUDED.max_height, quote_volume=EXCLUDED.quote_volume, txs_count=EXCLUDED.txs_count, volume=EXCLUDED.volume, weighted_average_price=EXCLUDED.weighted_average_price"`;

exports[`candles daemon sql test insert or update candles empty 1`] = `";"`;

exports[`candles daemon sql test insert or update candles from height 1`] = `"insert into \\"candles\\" select to_timestamp(floor((extract('epoch' from time_start) / 300 )) * 300) as \\"candle_time\\", \\"amount_asset_id\\" as \\"amount_asset_id\\", \\"price_asset_id\\" as \\"price_asset_id\\", (select min(\\"low\\")) as \\"low\\", (select max(\\"high\\")) as \\"high\\", (select sum(\\"volume\\")) as \\"volume\\", (select sum(\\"quote_volume\\")) as \\"quote_volume\\", (select max(\\"max_height\\")) as \\"max_height\\", (select sum(\\"txs_count\\")) as \\"txs_count\\", (sum((weighted_average_price * volume)::numeric)::numeric / sum(volume)::numeric)::numeric as \\"weighted_average_price\\", (array_agg(open ORDER BY time_start)::numeric[])[1] as \\"open\\", (array_agg(close ORDER BY time_start DESC)::numeric[])[1] as \\"close\\", 300 as \\"interval_in_secs\\", \\"matcher\\" as \\"matcher\\" from \\"candles\\" where \\"interval_in_secs\\" = 60 and time_start >= to_timestamp(floor(extract('epoch' from '2019-01-01T00:00:00.000Z'::timestamp) / 300) * 300) group by \\"candle_time\\", \\"amount_asset_id\\", \\"price_asset_id\\", \\"matcher\\" on conflict (time_start, amount_asset_id, price_asset_id, matcher, interval_in_secs) do update set open=EXCLUDED.open, close=EXCLUDED.close, low=EXCLUDED.low, high=EXCLUDED.high, max_height=EXCLUDED.max_height, quote_volume=EXCLUDED.quote_volume, txs_count=EXCLUDED.txs_count, volume=EXCLUDED.volume, weighted_average_price=EXCLUDED.weighted_average_price"`;

exports[`candles daemon sql test truncate table 1`] = `"truncate \\"candles\\" restart identity"`;
